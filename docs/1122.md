# 8085 微控制器的寻址方式

> 原文:[https://www.javatpoint.com/embedded-system-addressing-modes](https://www.javatpoint.com/embedded-system-addressing-modes)

寻址模式是用于与中央处理器通信以执行任何特定任务的指令集。

在 8085 微控制器中，通常使用以下**寻址模式**来执行指令

*   立即寻址模式
*   索引寻址模式
*   直接寻址模式
*   寄存器直接寻址模式
*   寄存器间接寻址模式

每种寻址模式的详细说明如下:

* * *

## 立即寻址模式

让我们从一个例子开始。

```
MOV A, #4AH 

```

简单来说，我们可以写，

```
MOV A, #data

```

之所以称为立即，是因为 8 位数据会立即发送到累加器(目标操作数)。

考虑下面描述上述指令集及其执行的插图。操作码 74H 保存在 0202 地址。数据 4AH 保存在程序存储器内的 0203 地址。在读取操作码 74H 之后，下一个存储器地址的数据被复制到累加器 A (E0H 是累加器的地址)。由于一条指令是 2 字节的，并且在一个周期内执行，程序计数器将增加 2，并指向程序存储器的 0204 地址。

![ES Addressing Models1](../Images/b6486bdd926fa10d79c17e6a5147bdc6.png)

* * *

## 索引寻址模式

让我们考虑两个例子来理解索引寻址模式的概念。请看下面的说明:

```
MOVC A, @A+DPTR
MOVC A, @A+PC

```

这里 PC 是程序计数器，DPTR 是数据指针(两者都是 16 位寄存器)。考虑第一个例子。

```
MOVC A, @A+DPTR

```

在这种情况下，源操作数是@A+DPTR。它有那个地方的原始数据。这里，DPTR 的内容与累加器的当前内容相加。这种添加提供了一个新地址，即源数据的地址。该地址指向的数据被进一步传输到累加器。

![ES Addressing Models2](../Images/a2a7e59bbaa79fb4825b32835b0726a5.png)

考虑操作码是 93H。值为 01FE 的 DPTR，这里 01 位于 DPH 侧(高 8 位)，FE 位于 DPL 侧(低 8 位)。考虑累加器的值为 02H。之后，16 位相加完成，01FE H+02H 产生 0200H。0200H 位置的数据将传输到累加器。累加器的先前值(02H)将被 0200H 的新数据取代。图中突出显示了累加器中的新数据。

* * *

## 直接寻址模式

直接寻址模式用于寻址操作数。这里，数据(源数据)的地址作为操作数存在。让我们考虑一个例子。

```
MOV A, 07H 

```

寄存器组#0(第 7 个寄存器)具有地址 07H。当执行 MOV 指令时，存储在寄存器 07H 中的数据被移入累加器。由于寄存器 07H 保存数据 1FH，因此 1FH 被移动到累加器。

**注意** -我们没有在直接寻址模式中使用“#”，就像在立即模式中使用的那样，因为如果我们使用了“#”，数据值 07H 将被传输到累加器，而不是 1FH。

现在，考虑下图。它显示了指令是如何执行的

![ES Addressing Models3](../Images/39b2fa950c9f7401ffe630af35dcfca8.png)

如上图所示，这是一条 2 字节指令，需要 1 个周期才能完成。

程序计数器将增加 2，并指向 0204 存储单元。指令 MOV 的操作码是 E5H。每当 0202 指令运行时(E5H)，累加器将变为活动状态，准备接收数据。然后，在 0203，个人计算机跳转到下一个地址，并查找源数据(即传输到累加器)所在位置 04H 的地址。在 04H，控制器找到数据 1FH 并将其传送到累加器，因此指令的执行完成。

* * *

## 寄存器直接寻址模式:

在寄存器直接寻址模式中，我们直接使用寄存器名称(作为源操作数)。

让我们考虑一个例子。

```
MOV A, R4 

```

一次，寄存器能够从 R0 到 R7 取值。微控制器中有 32 个这样的寄存器。为了使用这 32 个只有 8 个变量的寄存器来寻址寄存器，需要使用寄存器组。

一次只能选择一个寄存器组。通过使用一个名为处理器状态**字** (PSW)的**特殊功能寄存器** (SFR)，可以选择一个寄存器组。PSW 是一个 8 位 SFR，其中每个位都可以根据需要进行编程。位从 PSW.0 分配到 PSW.7

现在，考虑下图。它表示指令是如何执行的

![ES Addressing Models4](../Images/c805e75a13fb61925f54fbe8f6ad3c25.png)

数据(2F)移动以粗体显示。2F 从数据存储单元 0CH 转移到累加器，用虚线表示。0CH 是寄存器组#1 的寄存器 4 的地址位置。上面显示的指令为 1 字节，需要 1 个周期才能完全执行。这意味着我们可以通过使用直接寻址模式来节省内存。

* * *

## 寄存器间接寻址模式

在寄存器间接寻址模式下，数据地址作为操作数存储在寄存器中。

```
MOV A, @R0 

```

这里，R0 中的值被认为是一个地址，它用于保存要在累加器中传输的数据。示例:如果寄存器 R0 的值为 20H，并且数据 2FH 存储在 20H 的地址位置，则 2FH 的值将在执行上述指令后转移到累加器。

现在，考虑下图。它显示了指令是如何执行的

![ES Addressing Models5](../Images/2e582b2ca3981db85a46edb4f24d18f7.png)

考虑 MOV A 的操作码，@R0 是 E6H。程序控制移动到地址位置 20H，在那里它定位数据 2FH，然后在累加器内传送 2FH。这是一个 1 字节的指令，程序计数器(PC)递增 1，并移动到程序存储器的 0203 位置。

**注**:只允许寄存器 R0 和 R1 作为寄存器间接寻址指令。因此，程序员可以使用@R0 或@R1 来开发指令。不允许所有其他注册银行。